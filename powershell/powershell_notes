##################################
These notes came from:
https://www.youtube.com/watch?v=4X_uBL2YpmA


.ps1- script files
.psm1 - script module files

Double Quotes and single quotes do different things. Double quotes will allow powershell to interpret variables. A single quote will print exactly what you have in between the qutoes.  (eg '$message $message' will print $message $message while "$message $message" will print whatever the value of the message variable is twice.)

Read-Host- Read input form user. 

-and = both conditions must be true
-or = only one of the conditions msut be true. 
^ yes, there is a hyphen in front of and and or 

-eq 
-lt
-gt
-ne - not equal
-ge
-le


Operator precedence works left to right except for negation operators (!, -not, -bnot), which work right to left. 
You can override precedence by using parenthesis. 


Parameters allow you to pass an object to a cmdlet, function or script

powershell is object based. 
    jUst because you see text on the screen that does not mean it is a string. It is sactually a "string" object. 

    The example from the video is as follows: Get-ChildItem is basically a dir. The example shown is that he saves the output of the Get-ChildItem to $files ($files=Get-ChildItem). Once there he can call any of the column headers (Mode, LastWriteTime, Length, Name). $files.Name, will show you the names of all the files.

piping is a way of moving something, unchanged, from one place to another. 
    When passing to another cmdlet, $_ is used to reference the passed object. 
    $_ is a reserved variable name that can't be used for any variables. 

Get-ChildItem | Where-Object { $_. Name -eq "logs"}

Loops:
    ForEach
    ForEach-Object
    for
    while
    do while
    do until

Get-ChildItem | ForEach-Object { Write-Output $_.name}

Comments are defined by the # symbol. Block comments are enclosed with <# and #>

.Synopsis
.Description
.Paramter
.Example
 You can use the above keywords within a code block <# #>

 Get-ChildItem Recurse



 $files=Get-ChildItem
 $files | Get-Member
##################################

Chapter 3
start-job - Creates and executes a new local or remote background job
Receive-Job - Retrieves output generated by a background job
Wait-Job - Instructs Windows Powershell to wait for a background job to complete
Stop-Job - Halts the execution of a background job
Get-Job - Retrieves information about the status of a background job
Remove-Job - Deletes a background job object (including all its output)

====
To run an background job. 
Start-Job -ScriptBlock { <command to run> }
====
To run a job on a rmeote machine
Start-job -ScriptBlock { Get-Service -computer localhost }
====
Run a script as a background job
start-job -filepath <path to script> 
====
Running a background job with administrative credentials
start-job -filepath <path> -credential jlf04
====
How to retrive information from a job.  Firstly you will know by running the following command:
Get-job <job number< or simply Get-Job
2) HasMoreData --> will be set to true
3) Receive-job <job number> 

====
To stop a job --> Stop-Job 2
====
To remove a job --> Remove-Job

Can schedule jobs as well:
Register-ScheduledJob - Registers a job with the windows task scheduler
New-JobTrigger - Defines the job that is being scheduled
New-ScheduledTaskOption - Specifies various options that affect scheduled job execution. 

Example:
Register-ScheduledJob -Name DailyFielClean -filepath <path> (New-JobTrigger -Daily -At 11pm) -ScheduledJobOption (New-Scheduled-JobOption -WakeToRun)

====
To get help help on scheduled jobs --> 
Get-Help about_scheduled_jobs
Get-Help about_scheduled_jobs_Advanced
Get-Help about_scheduled_jobs_Basics
Get-Help about_scheduled_jobs_Troubleshooting

Object pipelines are the conduit through which comdlets pass object data to one another.  Pipelines are created using the | character. Using pipelines, you can combine two or more cmdlets to compose a logical statement that takes advantage of the combined capabilities of both cmdlets. 

Get-ChildItem | Sort-Object | Where-Object { $_.length -gt 200 }
    --> $_ is a special varaible created and maintained by Windows Powershell (No programmer created vriables can begin with $_). is automatically assigned the name of the current object in the powershell pipeline and, in the case of the Where-Object cmdlet, to reference each object in a collection. 

====
If you want to know what aliases exist for a given cmdlet, you can use the command:
    Get-Alias -Definition "Get-ChildItem"


##################################################################################################################################################################################################
Chapter 4

To learn more about reserved words
Get-Help About-reserved-words

Windows Powershell escape characters
`' single quote
`" double quote
`O Null
`a Alert
`b Backspace
`f Form feed
`n newline
`r Carriage return
`t Horizontal tab
`v Vertical tab

Ben0xa presentation covers similar topic around the 15 minute mark. 

String creation
$x = "example "
$y = "example 2"
$z = $x + $y == example example 2

Replace argument:
$x = "Once upone a time there was a little boy."
$y = $x -replace "boy", "girl"
$y is now equal to "once upone a time there was a little girl"

PS C:\> "1,2,3,4,5" -split ","
1
2
3
4
5

There is a join operator
$alphabet = -join ("abcefghij", "klmnopqr", "stuvwxyz")

Varables are not case sensitive. 

Unlike python that will tell you that a variable is being used before being defined, powershell will not give you that error and will go ahead and run.  The results can be unpredictable otherwise. 

Reminder - Print a statement with double quotes will substitute the value of the variable. If you use a single quote you will see $x in the output rather then the vlue of $x. 

Powershell assignment operators:
= assigns a value to a variable
+= Adds a value to a variable
-= subtracts a value from a variable
*= multiplies a value to a variable
/= divides a variable value
%= performs a modulo. 

++ increase the value by 1 
-- subtracts the value by 1. 

Special variables:
$- Represents the current pipeline object when used in script blocks such as ForEach-Object and the Where-Object blocks

$Error - Provides access to information about recent errors
$HOME- Rpresents the home directory of the current user. 
$PSHOME - represents the home directory of the current user
$null - represents a null object. 

Can learn more about automatic variables through Get-Help about_automatic_variables

Global and local variables I believe are referred to as local, and global scopes. This I am assuming will be covered more in chapter 7. 

Creating an array
$names= @("Alexander", "William", Molly")

Trick: Can use negative numbers to refer to items at the end of an array. -1 refers to last item, -2 refers to second to last. 

If creating an array made up of numeric data, you can omit enclosing array elements inside matching quotations marks. 
$numbers=@(1,2,3,4,5)

If you want to call up a range of items from a list, a user can use the .. notation. 
$numbers=@(1..5)

To modify element value can use
    $numers[2]=9

To track the size of a array
    $numbers.count and can also use length. 

No direct way to delete an item from an array. Assuming you have an 8 item array and want to delete item 4. Can do:
$numbers=$numbers[0..3 + 5..8]

No direct way to add an item to an array but can follow a similar approach as the previous example. To add value 99 to item 4. 
$numbers=$numbers[0..3 + 99 + 5..8]

Associative Arras = Dictionary
$ids=@{}

$ids[123456]="William"
$ids[23456]= "Alexander"
$ids[34567]="Molly"

To Access data:
$x=$ids[34567]

To populate associative arrays at creation time:
$nicknames=@{Alexander="X-MAN";William="William-D";Molly="Mighty-One"}

Interesting note from note taker: write-host $nicknames, gives a different output then write-output $nicknames

To delete a key pair
$nicknames.Remove("Alexander")

===========================================================
Chapter 5
Conditional logic:
    -If: Statement evaluates a comparison and then executes or skips the execution of statement located in the code block. 
    -switch: This statement supports the execution of multiple comparison operations. 

Switch statement 

Logical operators. 
-not
! - not
-and 
-or

String comparison operatiors
operator    Description                     Case-sensitive
-ieq        equal to                        No
-ilt        less then                       No
-igt        Greater than                    No
-ige        Greater then or equal To        No
-ile        Less than or equal to           No
-ine        not equal                       No
-ceq        Equal To                        Yes
-clt        Less than                       Yes
-cgt        Greater than                    Yes
-cge        Greater or equal To             Yes
-cle        less than or equal to           Yes
-cne        not equal To                    Yes


*Note after reading through the above chart the i or the c tell you whether or not it is case sensitive. ieq is not case sensitive and ceq is case sensitive. 

Chapter 6:
do while- Iterates the delinated code while a specified condition is true
do until- Iterates the delineated code until a specified condition is true
for- iterates the delineated code a set number of times. 
foreach- Iterates through all the elements stored in a colleciton or array. 
while- Iterates the delineated code as long as, or while, its conditional test remains true. 

do loop- loops as long as or while, the tested condition remains true. Since the condition being evalued is done at the end of the loop, you can count on the loop always executing at least once. 
Sample code:
    $i=1
    do {
        Write-Host $i
        $i++
    } while ($i -le 10)

Do until loop executes until a test condition evaluates to true or in other words, do until loop executes as long as a condition is false. 
Sample code
$i = 1

do { 
Write-Output $i
$i++
} until ($i -g 10)

What will happen here is that this code will not run until $i is greater then 10. 

================================================================================================
For loop through an array:
$numbers=@(1,2,3,4,5,6,7,8,9,10)

for ($i = 0; $i -le $numbers.Length -1; $i += 2) {
    Write-output $numbers[$i]
}

    $numbers.Length -1 --> This is interesting, because this is how the for loop knows when to stop. The array length is 10, but since the counting starts at 0, $i only needs to iterate through numbers 0-9. Once $i = 10, there is no 11th position in the array and that is why the -le condition statement is used. 

================================================================================================
foreach loop can also process data returned by cmdlets such as Get-Process and Get-ChildItem which return results in the form of a collection. 

foreach ($x in Get-Service)     {
  if ($x.Status -eq "Running") {Write-Host $x. Name}
  }

  Foreach loops are more the loop types that I have found in other programming langugage. It will iterate through an array and stop at the end. While the for mentioned above will behave similar to a while loop. 
================================================================================================
While loop:

$i = 1
 while ($i -le 10) {
 Write-output $i
 $i++
 }

Unlike the do while loop mentioned earlier in the notes, this code block will not run at all unless the condition is met. 

================================================================================================
Two ways to manipulate a for loop:

break command will terminate the loop. eg, 
for ($i =1; $i -le 10; $i++) {
    if ($i -eq 5) {
        break
    }
    Write-Host $i
}

The above code will print the numbers 1,2,3,4

The continue command will terminate the current iteration of the innermost loop, but will continue operating the remainder of the for loop. 
$i = 1

while ($i -le 10) {
    if ($i -eq 5) {
    $i++
     continue
    }
    Write-Host $i 
    $i++
}

From trick section:
Windows Powershell supports the exit command. When executed, this comman terminates the execution of the entire script, not just the current iteration of a loop. 
if ($x - gt 100) {
    Write-Host "Error - Maximum value exceeded"
    exit
}

    This appears to be similar to sys.exit in python. 

====================================================================
Functions

Define all your functions in a central loction at the beginning of your powershell script. This ensures that all your functions are defined and initialzed before they are called upon. 

My first function:
    
    function hello {
    Write-Output "Hello world"
    }

    hello

My first function passing variables:
    function somethingDifferent ($x, $y) {
    $z = $x + $y
    Write-Output $z
    }

    somethingDifferent 4 5 # Passing the numbers 4 & 5 to the somethingDifferent funciton

Trick- You can pass functions parameters by position or named. In the example above 4 was the $x variable since it was passed first to the function. Another option is to pass the names to the function eg( somethingDifferent -x 4 -y 5)

Another way to pass variables to the function is to use the param arguement
    function anotherExample {
    param ($x, $y)
    $z = $x + $y
    Write-Output $z
    }

    This example works the exxact same was as function somethingDifferent worked above. 

#####
How to specify argument data type
function Add-Numbers {
    Param ([int]$x, [int]$y)
    $z = $x + $y
    Write-Host $z
}

Add-Numbers -x 2 -y 3

Now if you pass a non-integer to the function you will get an error in Powershell. 

####
Other kinds of data types that can be used
[array]                 [hashtable]
[boo]                   [int]
[byte]                  [long]
[char]                  [single]
[DateTime]              [string]
[Decimal]               [xml]
[double]


Assigning default values to arguments:

function Add-Numbers {
    param ([int]$x=0, [int]$y=0)
    $z = $x + $y
    Write-Host $z
}

Add-Numbers -y 2 --> This will return a value of 2 since we will use the default value for x. 

####
How to return a result. 
function Add-Numbers {
    param ([int]$x=0, [int]$y=0)
    $result = $x + $y
    $Result
}

In this example, the Add-Numbers function takes two integer values passed to it as arguments and adds them. It then returns this result to the statement that called it by assigning the value to be returned to the $resultvaraible, which is then reference against the last statement executed by the function. 

script-level scope variable is a global variable. 

An example:
    $userName = ""
    function Get-UserName {
        $script:userName = Read-Host "What is your name"
    }

    Get-UserName
    Write-Host "Hello $userName"

Private varible is a local variable equivalent in Python
function Get-Username {
        $private:x = Read-Host "What is your name?"
    }
Get-UserName
write-output "Hello $x"

################################################################################################
Working with files and folders

To match simple mpatterns, can use the -match operator. 

if ("Once upon a time" -match "ONCE") {
    Write-Host "Match!"
}

You can have a case sensitive match by using -cmatch. 

-nomatch argument will be processed when the desired criteria is NOT in the string.  Since XXX is not in the string "Once upon a time", then "we have a match" will print. 
if ("Once upon a time" -notmatch "XXX") { 
    Write-Host "We have a match"
}

####
Matching alternative patterns
if ("mar" -match "war|mar|jar") {
    Write-Host "Match!"
}

The above lines can also be written as:
if ("mar" -match "(wa|ma|ja)r") {
    Write-Host "match!"
}

#Remember to comment out special characters. FOr example
if ("the winner of this year's award is Mrs. Ford!" -match "Mr.")

    #Since a period means match a single character in regex, the string above would incorrectly match Mrs. Mrr, Mrs, etc. That is assuming we only want to match Mr. 

    The above line to only match Mr. would be
    if ("The winner of this year's award is Mr. Ford!" -match Mr\.)

    Regex cheat sheet:
    [a-z] all lower case letters
    [A-Z] all upper case letters
    [0-9] all numbers 0-9

    Character class shortcuts
    \d - numbers 0-9
    \w equivalent to [0-9A-Za-z_]
    \s equivalent to [\t\f\r\n\v]
    \D Matches any character besides [0-9]
    \W matches any characters besides [0-9A-za-z]
    \S Matches any characters besides [\t\f\r\n\v]

Can find out more about regular expressions via Get-Help about_regular_expression

Test-Path- Can be used to see if a file exist
write-warning- has the same syntax as write-host cmdlet, but when executed, it displays the text string warning: followed by the text. 


How to get length of a single file:
(Get-Item "C:\xerox").length

copy file- copy-item
Delete file - remove-item
Rename file - Rename-item
To read a file- Get-content
    To grep/search a file - select-string "String to find"
    example Get-content <filename> | select-string "hello"

Create new file- New-Item c:\newfile -type file
Create new directory- New-Item C:\folder -type directory
    * If you want to overwrite the existing file or folder use the -force flag/option


Writing text:
Can use > and >> redirectors
Set-Content C:\temp\temp.txt "Once upon a time"
Instead of > can use Out-file cmdlet
Instead of >> can use add-content cmdlet. 


Can modify how the output looks like. 
Format-List will output in list format. 
format-table will output in table format. 

Read textfile- get-content
erase file contents- clear-content

Can natively read and export into csv and xml formats. 

When running get-process you can view the output in the intepreter, or you can open up a window similar to that of tasklist with the command out-gridview. 

Can send data to the printer with the out-printer cmdlet. 
    Quick printer test --> Get-location | out-printer

