##################################
These notes came from:
https://www.youtube.com/watch?v=4X_uBL2YpmA


.ps1- script files
.psm1 - script module files

Double Quotes and single quotes do different things. Double quotes will allow powershell to interpret variables. A single quote will print exactly what you have in between the qutoes.  (eg '$message $message' will print $message $message while "$message $message" will print whatever the value of the message variable is twice.)

Read-Host- Read input form user. 

-and = both conditions must be true
-or = only one of the conditions msut be true. 
^ yes, there is a hyphen in front of and and or 

-eq 
-lt
-gt
-ne
-ge
-le


Operator precedence works left to right except for negation operators (!, -not, -bnot), which work right to left. 
You can override precedence by using parenthesis. 


Parameters allow you to pass an object to a cmdlet, function or script

powershell is object based. 
    jUst because you see text on the screen that does not mean it is a string. It is sactually a "string" object. 

    The example from the video is as follows: Get-ChildItem is basically a dir. The example shown is that he saves the output of the Get-ChildItem to $files ($files=Get-ChildItem). Once there he can call any of the column headers (Mode, LastWriteTime, Length, Name). $files.Name, will show you the names of all the files.

piping is a way of moving something, unchanged, from one place to another. 
    When passing to another cmdlet, $_ is used to reference the passed object. 
    $_ is a reserved variable name that can't be used for any variables. 

Get-ChildItem | Where-Object { $_. Name -eq "logs"}

Loops:
    ForEach
    ForEach-Object
    for
    while
    do while
    do until

Get-ChildItem | ForEach-Object { Write-Output $_.name}

Comments are defined by the # symbol. Block comments are enclosed with <# and #>

.Synopsis
.Description
.Paramter
.Example
 You can use the above keywords within a code block <# #>

 Get-ChildItem Recurse



 $files=Get-ChildItem
 $files | Get-Member
##################################

Chapter 3
start-job - Creates and executes a new local or remote background job
Receive-Job - Retrieves output generated by a background job
Wait-Job - Instructs Windows Powershell to wait for a background job to complete
Stop-Job - Halts the execution of a background job
Get-Job - Retrieves information about the status of a background job
Remove-Job - Deletes a background job object (including all its output)

====
To run an background job. 
Start-Job -ScriptBlock { <command to run> }
====
To run a job on a rmeote machine
Start-job -ScriptBlock { Get-Service -computer localhost }
====
Run a script as a background job
start-job -filepath <path to script> 
====
Running a background job with administrative credentials
start-job -filepath <path> -credential jlf04
====
How to retrive information from a job.  Firstly you will know by running the following command:
Get-job <job number< or simply Get-Job
2) HasMoreData --> will be set to true
3) Receive-job <job number> 

====
To stop a job --> Stop-Job 2
====
To remove a job --> Remove-Job

Can schedule jobs as well:
Register-ScheduledJob - Registers a job with the windows task scheduler
New-JobTrigger - Defines the job that is being scheduled
New-ScheduledTaskOption - Specifies various options that affect scheduled job execution. 

Example:
Register-ScheduledJob -Name DailyFielClean -filepath <path> (New-JobTrigger -Daily -At 11pm) -ScheduledJobOption (New-Scheduled-JobOption -WakeToRun)

====
To get help help on scheduled jobs --> 
Get-Help about_scheduled_jobs
Get-Help about_scheduled_jobs_Advanced
Get-Help about_scheduled_jobs_Basics
Get-Help about_scheduled_jobs_Troubleshooting

Object pipelines are the conduit through which comdlets pass object data to one another.  Pipelines are created using the | character. Using pipelines, you can combine two or more cmdlets to compose a logical statement that takes advantage of the combined capabilities of both cmdlets. 

Get-ChildItem | Sort-Object | Where-Object { $_.length -gt 200 }
    --> $_ is a special varaible created and maintained by Windows Powershell (No programmer created vriables can begin with $_). is automatically assigned the name of the current object in the powershell pipeline and, in the case of the Where-Object cmdlet, to reference each object in a collection. 

====
If you want to know what aliases exist for a given cmdlet, you can use the command:
    Get-Alias -Definition "Get-ChildItem"


##################################################################################################################################################################################################
Chapter 4

To learn more about reserved words
Get-Help About-reserved-words

Windows Powershell escape characters
`' single quote
`" double quote
`O Null
`a Alert
`b Backspace
`f Form feed
`n newline
`r Carriage return
`t Horizontal tab
`v Vertical tab

Ben0xa presentation covers similar topic around the 15 minute mark. 

String creation
$x = "example "
$y = "example 2"
$z = $x + $y == example example 2

Replace argument:
$x = "Once upone a time there was a little boy."
$y = $x -replace "boy", "girl"
$y is now equal to "once upone a time there was a little girl"

PS C:\> "1,2,3,4,5" -split ","
1
2
3
4
5

There is a join operator
$alphabet = -join ("abcefghij", "klmnopqr", "stuvwxyz")

Varables are not case sensitive. 

Unlike python that will tell you that a variable is being used before being defined, powershell will not give you that error and will go ahead and run.  The results can be unpredictable otherwise. 

Reminder - Print a statement with double quotes will substitute the value of the variable. If you use a single quote you will see $x in the output rather then the vlue of $x. 

Powershell assignment operators:
= assigns a value to a variable
+= Adds a value to a variable
-= subtracts a value from a variable
*= multiplies a value to a variable
/= divides a variable value
%= performs a modulo. 

++ increase the value by 1 
-- subtracts the value by 1. 

Special variables:
$- Represents the current pipeline object when used in script blocks such as ForEach-Object and the Where-Object blocks

$Error - Provides access to information about recent errors
$HOME- Rpresents the home directory of the current user. 
$PSHOME - represents the home directory of the current user
$null - represents a null object. 

Can learn more about automatic variables through Get-Help about_automatic_variables

Global and local variables I believe are referred to as local, and global scopes. This I am assuming will be covered more in chapter 7. 

Creating an array
$names= @("Alexander", "William", Molly")

Trick: Can use negative numbers to refer to items at the end of an array. -1 refers to last item, -2 refers to second to last. 

If creating an array made up of numeric data, you can omit enclosing array elements inside matching quotations marks. 
$numbers=@(1,2,3,4,5)

If you want to call up a range of items from a list, a user can use the .. notation. 
$numbers=@(1..5)

To modify element value can use
    $numers[2]=9

To track the size of a array
    $numbers.count and can also use length. 

No direct way to delete an item from an array. Assuming you have an 8 item array and want to delete item 4. Can do:
$numbers=$numbers[0..3 + 5..8]

No direct way to add an item to an array but can follow a similar approach as the previous example. To add value 99 to item 4. 
$numbers=$numbers[0..3 + 99 + 5..8]

Associative Arras = Dictionary
$ids=@{}

$ids[123456]="William"
$ids[23456]= "Alexander"
$ids[34567]="Molly"

To Access data:
$x=$ids[34567]

To populate associative arrays at creation time:
$nicknames=@{Alexander="X-MAN";William="William-D";Molly="Mighty-One"}

Interesting note from note taker: write-host $nicknames, gives a different output then write-output $nicknames

To delete a key pair
$nicknames.Remove("Alexander")
